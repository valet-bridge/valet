Probably QF etc should also be STAGE, not ITERATOR.

Reductions:
1. ITERATOR, FIELD Rof
   SEPARATOR
   SINGLETON, FIELD NUMERAL, 4 8 12 16 18 32 64 128
   -> SINGLETON, STAGE, could be QF, Rof12, ..., no value

In Cookbook, pick out the values and map to AMBIGUOUS in
the big hash already.

3. Two tokens like to combine with a binding strength 0-9
   that is specified in rules
5. An ambiguous token perhaps only merges if there is only
   one possible merge.  Only later by strength if needed.
7. Some cross-chain merges are possible, "4 (of 7)".

Maybe my chain reductions are too quick.
- If no space at all, split on dash into chains
- "10 B" becomes an unamed COUNTER_DOUBLE.

Then there is a reduction rule
Round 7 B of 9
7 B -> generic counter_double
any counter without of + "of N" -> generic counter_double_of
any ^ iterator + generic_counter_double_of = specific_counter_double_of
So these rules can bubble up
Each reduction rule can have a score.
"of" + "8" = "of 8" binds very strongly.
2 B binds strongly as well.


Qletter, dash, Final (ITER-SEP-ITER), merge to QF
2 B (NUM-SEP-LETTER)
2:1 (NUM-SEP-NUM with colon), round and segment?


When KILL'ing, also preserve the text of the surrounding separators.

Make something called Region.pm with Kepri in it

Binary coding of the ~ 30 categories?
Categories:

TNAME
SPONSOR
MEMORIAL
ORGANIZER
TOURNAMENT
MOVEMENT
ORIGIN
FORM
SCORING

ITERATOR

AGE
GENDER

GROUP
COLOR
TABLE
BOARDS

COUNTRY
REGION
GEOCOVER
CITY

YEAR
MONTH
DATE
WEEKDAY
TEMPORAL

ORDINAL
NUMERAL
ROMAN

PARTICLE

KILL
