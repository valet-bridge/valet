Probably QF etc should also be STAGE, not ITERATOR.

Reductions:
1. ITERATOR, FIELD Rof
   SEPARATOR
   SINGLETON, FIELD NUMERAL, 4 8 12 16 18 32 64 128
   -> SINGLETON, STAGE, could be QF, Rof12, ..., no value

2. SINGLETON, PARTICLE, VALUE Of
   SEPARATOR
   SINGLETON, FIELD NUMERAL
   -> ITERATOR, no field, the OF entry has NUMERAL set

3. SINGLETON, NUMERAL
   SEPARATOR, FIELD has SLASH
   SINGLETON, NUMERAL (less than first one)
   -> ITERATOR, no field, BASE NUMERAL and OF NUMERAL


Tokens should use
CATEGORY: ITERATOR, SINGLETON, KILL, AMBIGUOUS, SEPARATOR
FIELD:    Round   , Date     , nth , nth      , nth
VALUE:    nothing , 2023---  , nth , nth      , SPACE etc.

Should be in Token already.
In Cookbook, pick out the values and map to AMBIGUOUS in
the big hash already.  That'


1. Tokens creates one list of Token's
2. A Chain is a list of Token's
3. Two tokens like to combine with a binding strength 0-9
   that is specified in rules
4. To begin with, tokens are quite simple, but in the case
   of iterators, they can amass more information
5. An ambiguous token perhaps only merges if there is only
   one possible merge.  Only later by strength if needed.
6. Each Chain has an ending separator (the last one is artificial).
7. Some cross-chain merges are possible, "4 (of 7)".
8. A chain may be marked as done.
9. A pair of tokens in a chain get marked with their merging strength.
   When two tokens are merged, the merging strength of the new
   token is updated.  (Chain may be complete at that point.)

Maybe my chain reductions are too quick.
- Split on all parentheses into chains
- If no space at all, split on dash into chains
- "1 of 2" becomes an unnamed COUNTER_SINGLE_OF.
- "10 B" becomes an unamed COUNTER_DOUBLE.

Then there is a reduction rule
Round 7 B of 9
7 B -> generic counter_double
any counter without of + "of N" -> generic counter_double_of
any ^ iterator + generic_counter_double_of = specific_counter_double_of
So these rules can bubble up
Each reduction rule can have a score.
"of" + "8" = "of 8" binds very strongly.
2 B binds strongly as well.


Qletter, dash, Final (ITER-SEP-ITER), merge to QF
2 B (NUM-SEP-LETTER)
2:1 (NUM-SEP-NUM with colon), round and segment?


When KILL'ing, also preserve the text of the surrounding separators.

Make something called Region.pm with Kepri in it

Binary coding of the ~ 30 categories?
Categories:

TNAME
SPONSOR
MEMORIAL
ORGANIZER
TOURNAMENT
MOVEMENT
ORIGIN
FORM
SCORING

ITERATOR

AGE
GENDER

GROUP
COLOR
TABLE
BOARDS

COUNTRY
REGION
GEOCOVER
CITY

YEAR
MONTH
DATE
WEEKDAY
TEMPORAL

ORDINAL
NUMERAL
ROMAN

PARTICLE

KILL
